package provider

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/cachepump/cachepump/cache"
)

const (
	testData = "Hello! Test is successful!"
)

func TestAuth_String(t *testing.T) {
	type fields struct {
		User     string
		Password string
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		{
			name: "Auth with password in 5 symbols",
			fields: fields{
				User:     "user1",
				Password: "12345",
			},
			want: "{User:user1 Password:*****}",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			a := Auth{
				User:     tt.fields.User,
				Password: tt.fields.Password,
			}
			if got := a.String(); got != tt.want {
				t.Errorf("Auth.String() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHttp_IsEmpty(t *testing.T) {
	type fields struct {
		Endpoint string
		Method   string
		Auth     Auth
		Header   http.Header
		Body     string
	}
	tests := []struct {
		name   string
		fields fields
		want   bool
	}{
		{
			name:   "Empty http provider",
			fields: fields{},
			want:   true,
		},
		{
			name: "No empty http provider",
			fields: fields{
				Endpoint: "http://0.0.0.0:8080",
				Method:   "GET",
				Auth:     Auth{User: "user1", Password: "12345"},
				Header:   http.Header{"Content-Type": []string{"application/json"}},
				Body:     "Hello!",
			},
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			h := Http{
				Endpoint: tt.fields.Endpoint,
				Method:   tt.fields.Method,
				Auth:     tt.fields.Auth,
				Header:   tt.fields.Header,
				Body:     tt.fields.Body,
			}
			if got := h.IsEmpty(); got != tt.want {
				t.Errorf("Http.IsEmpty() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHttp_Pump(t *testing.T) {

	// Initialisation of environments.
	srv := initHttpProvider()
	defer cleaneHttpProvider(srv)

	type fields struct {
		Endpoint string
		Method   string
		Auth     Auth
		Header   http.Header
		Body     string
	}
	type args struct {
		name string
	}
	tests := []struct {
		name           string
		fields         fields
		args           args
		wantCacheValue []byte
		wantCacheErr   bool
	}{
		{
			name: "Using not available http server",
			fields: fields{
				Endpoint: "http://0.0.0.0:1234",
			},
			args:           args{name: "no_http"},
			wantCacheValue: []byte{},
			wantCacheErr:   true,
		},
		{
			name: "Using test http server. Request without header",
			fields: fields{
				Endpoint: srv.URL,
			},
			args:           args{name: "empty_header"},
			wantCacheValue: []byte("using json"),
			wantCacheErr:   false,
		},
		{
			name: "Using test http server. Request with header and auth",
			fields: fields{
				Endpoint: srv.URL,
				Method:   "GET",
				Auth:     Auth{User: "admin", Password: "admin"},
				Header:   http.Header{"Content-Type": []string{"application/json"}},
				Body:     "test",
			},
			args:           args{name: testData},
			wantCacheValue: []byte(testData),
			wantCacheErr:   false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			h := Http{
				Endpoint: tt.fields.Endpoint,
				Method:   tt.fields.Method,
				Auth:     tt.fields.Auth,
				Header:   tt.fields.Header,
				Body:     tt.fields.Body,
			}
			fn := h.Pump(tt.args.name)
			fn()
			value, err := cache.Get(tt.args.name)
			if (err != nil) != tt.wantCacheErr {
				t.Errorf("Job function generated by Http.Pump() returns error = %v", err)
			}
			if string(value) != string(tt.wantCacheValue) {
				t.Errorf("Job function generated by Http.Pump() returns value = %s, want = %s", value, tt.wantCacheValue)
			}
		})
	}
}

func initHttpProvider() (srv *httptest.Server) {
	return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if cp := r.Header.Get("Content-Type"); cp != "application/json" {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("using json"))
			return
		}

		w.WriteHeader(200)
		w.Write([]byte(testData))
	}))
}

func cleaneHttpProvider(srv *httptest.Server) {
	srv.Close()
}
